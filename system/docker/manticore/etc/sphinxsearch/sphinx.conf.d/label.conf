#!/bin/sh
set -eu
cat <<EOF

#################
# this index's, sole purpose is to run updates. So that the real "label" index can connect to replica/slave

source label_master : db_master
{
        sql_query_pre           = REPLACE INTO sph_counter SELECT 'label', MAX(gridimage_id)-1000,'$HOSTNAME' as server_id, NOW() FROM gridimage_search

        #something really trivial, but got most compatiblity, return a text field. Never searched, so doesnt matter what contains
        # the 4 seconds, is HOPEFULLY to give the slave time to catch up.
        sql_query = SELECT gridimage_id,title,sleep(4) AS dummy FROM gridimage_search LIMIT 1
}

#################

source label_main : db_slave {

        sql_query_pre           = SET CHARACTER SET 'utf8'
        sql_query_pre           = SET SESSION query_cache_type=OFF
        sql_query_pre           = SET SESSION group_concat_max_len = 100000
	sql_query_pre           = SET SESSION max_statement_time = 600

	## Get a global lock so that only one manticore instance can index at a time. Even if lock expires we've somewhat desynced the various instances
	sql_query_pre           = SELECT GET_LOCK('label',500+ROUND(RAND()*100))
	sql_query_post          = SELECT RELEASE_LOCK('label')

	sql_query_range         = SELECT 1,max_doc_id FROM sph_counter WHERE counter_id='label' and server_id='$HOSTNAME'
        sql_range_step          = 100000

sql_query = SELECT \
        gi.gridimage_id, gi.user_id, \
        gi.title, gi.realname, gi.comment, gi.imageclass, gi.tags, CONCAT('user',gi.user_id) as user, \
        IF(gi.moderation_status='accepted','supplemental',gi.moderation_status) AS status,\
        SUBSTRING(gi.grid_reference,1,LENGTH(gi.grid_reference)-4) AS myriad,\
        CONCAT(SUBSTRING(gi.grid_reference,1,LENGTH(gi.grid_reference)-3),SUBSTRING(gi.grid_reference,LENGTH(gi.grid_reference)-1,1)) AS hectad,\
        gi.grid_reference, RADIANS(wgs84_lat) AS wgs84_lat, RADIANS(wgs84_long) AS wgs84_long,\
\
 GROUP_CONCAT(IF(model = 'top',label,NULL) ORDER BY l.score DESC) AS top,\
 COALESCE(GROUP_CONCAT(IF(model = 'typev2',label,NULL) ORDER BY l.score DESC), GROUP_CONCAT(IF(model = 'type',label,NULL) ORDER BY l.score DESC)) AS type,\
 GROUP_CONCAT(IF(model = 'subject',label,NULL) ORDER BY l.score DESC) AS subject,\
 GROUP_CONCAT(IF(model = 'city',label,NULL) ORDER BY l.score DESC) AS city,\
 GROUP_CONCAT(IF(model LIKE 'tag%',label,NULL) ORDER BY l.score DESC) AS tag,\
 GROUP_CONCAT(IF(model = 'vision',label,NULL) ORDER BY l.score DESC) AS vision,\
 GROUP_CONCAT(IF(model = 'imageclass',label,NULL) ORDER BY l.score DESC) AS imageclass,\
 GROUP_CONCAT(IF(model = 'term',label,NULL) ORDER BY l.score DESC) AS term,\
\
        sequence, \
        SUBSTRING(MD5(CONCAT(gi.gridimage_id,gi.user_id,'secret-hash')),1,8) AS hash \
FROM gridimage_search gi \
	INNER JOIN gridimage_label l USING (gridimage_id) \
WHERE gi.gridimage_id>=\$start AND gi.gridimage_id<=\$end \
	AND l.score > 0.75 \
GROUP BY gridimage_id

sql_field_string	= title
sql_attr_uint           = user_id
sql_field_string	= grid_reference
sql_field_string        = realname

sql_attr_float          = wgs84_lat
sql_attr_float          = wgs84_long

sql_field_string = top
sql_field_string = type
sql_field_string = subject
sql_field_string = city
sql_field_string = tag
sql_field_string = vision
sql_field_string = image

sql_attr_uint           = sequence
sql_field_string        = hash

}
source label_delta : label_main
{
        sql_query_pre           = SET CHARACTER SET 'utf8'
        sql_query_pre           = SET SESSION query_cache_type=OFF

        sql_query_pre           = SELECT GET_LOCK(CONCAT('label',DATABASE()),30)

        sql_query_range         = SELECT max_doc_id+1,(SELECT MAX(gridimage_id) FROM gridimage_search)+1 FROM sph_counter WHERE counter_id='label' and server_id='$HOSTNAME'
        sql_range_step          = 500

        sql_query_post          = SELECT RELEASE_LOCK(CONCAT('label',DATABASE()))
}

#################

index label_master
{
        type                    = plain
        source                  = label_master
        path                    = /var/lib/manticore/data/label_master
        docinfo                 = none
}

index label_main
{
        type                    = plain
        source                  = label_main
        path                    = /var/lib/manticore/data/label_main

        min_word_len            = 1

        morphology              = stem_en
}

index label_delta : label_main
{
        source                  = label_delta
        path                    = /var/lib/manticore/data/label_delta
}

############################################
# a distributed index with same name as original single index, so queries dont change!

index label {
        type = distributed
        local = label_main
        local = label_delta
}


EOF

